@(rankings: Seq[RunRanking], rankingUsers: Seq[User], player: Player, windowMaybe: Option[Int] = None)

@import views.Helpers
@import views.timeTrials.RankingExtract

@rankingLine(ranking: RunRanking, outOfWindow: Boolean = false) = {
  <li class="rank-@ranking.rank @if(ranking.playerId == player.id) { current-player } @if(outOfWindow) { out-of-window }"
  title="@ranking.creationTime.toString("EEEE d - HH:mm")">

    <span class="rank">@ranking.rank</span>

    @rankingUsers.find(_.id == ranking.playerId) match {
      case None => {
        <span class="handle">@Messages("anonymous")</span>
      }
      case Some(user) => {
        <a href="@routes.Users.show(user.handle)" class="user-avatar">
          @views.html.users.avatar(user)
          <span class="handle">@user.handle</span>
        </a>
      }
    }

    @if(ranking.isRecent) { <abbr title="@Messages("timeTrials.recent")">*</abbr> }

    <span class="time">@if(ranking.rank == 1) {
      @Helpers.timer(ranking.finishTime)
    } else {
      @Helpers.timeDelta(ranking.finishTime - rankings.map(_.finishTime).min)
    }</span>

  </li>
}

<ul class="time-trial-rankings">
  @defining(RankingExtract.make(rankings, player, windowMaybe)) { extract =>

    @for(ranking <- extract.inWindow) {
      @rankingLine(ranking)
    }

    @extract.outOfWindow match {
      case Some(rankingOutOfWindow) => {
        @rankingLine(rankingOutOfWindow, outOfWindow = true)
      }
      case None => {
        @for(length <- windowMaybe.filter(_ > extract.inWindow.length)) {
          @for(_ <- 1.to(length - extract.inWindow.length)) {
            <li class="empty">&nbsp;</li>
          }
        }
      }
    }

  }
</ul>
